---
id: http
title: HTTP知识整理
author: 
author_title: 
author_url: 
author_image_url: 
tags: [ http, 面试 ]
---


#### HTTP

> HTTP叫做超文本传输协议，它是TCP/IP协议的一个应用层协议，用于定义Web浏览器与Web服务器之间的交换数据的过程，客户端连上web服务器后，若想获得web服务器中的某个web资源，需要遵循一定的通讯格式，HTTP协议用于定义客户端和web服务器端通讯的格式。

<!--truncate-->

#### HTTP报文的组成部分

- 请求报文
  - 请求行 --- 包含http方法，页面地址，http协议，http版本
  - 请求头 --- 包含一些key：value的值，eg： host、Cache-Control，Accept，Cookie等
  - 空行 --- 用来告诉服务端往下就是请求体的部分啦
  - 请求体 --- 就是正常的query/body参数
- 响应报文
  - 状态行 --- 包含http方法，http协议，http版本，状态码
  - 响应头 --- 包含一些key：value的值，eg： Content-type，Set-cookie, Cache-Control, Date, Server等
  - 空行 --- 用来告诉客户端往下就是响应体的部分啦
  - 响应体 --- 就是服务端返回的数据



#### HTTP方法

- GET -- 获取资源
- POST -- 传输资源
- PUT -- 更新资源，常用来做传输文件
- DELETE -- 删除资源
- HEAD -- 获取请求报文首部
- OPTIONS -- 询问支持的方法，查询针对请求URI指定的资源支持的方法



#### GET和POST请求的区别

- GET产生的URL地址可以被收藏，而POST不可以
- GET请求会被浏览器主动缓存，而POST不会，除非自动设置
- GET请求参数会被完整的保留在浏览器历史里，而POST的参数不会被保留
- GET请求在URL中传输参数有长度限制，而POST没有
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- POST比GET更安全，因为GET请求的参数直接暴露在URL上
- GET参数通过URL传输，而POST参数放在request body中



#### 常见状态码

- 1XX --- 指示信息，表示请求已接受，继续处理

- 2XX --- 成功，表示请求已被成功接受

- - 200 --- OK，客户端请求成功
  - 206 --- 客户端发送了一个带有Range头的GET请求，视频/音频可能会用到

- 3XX --- 重定向，要完成请求，必需进行近一步操作

- - 301 --- 重定向，所请求的界面转移到新的url，永久重定向
  - 302 --- 同上301，但是是临时重定向
  - 304 --- 缓存，服务端告诉客户端有缓存可用，不用重新请求

- 4XX --- 客户端错误，请求有语法错误或请求无法实现

- - 400 --- Bad Request， 客户端请求有语法错误
  - 401 --- Unauthorized, 请求未授权
  - 403 --- Forbidden, 禁止页面访问
  - 404 --- Not found， 请求资源不存在

- 5XX --- 服务端错误，服务器未能实现合法的请求

- - 500 --- Internal Server Error, 服务器错误
  - 503 --- Server Unavailable, 请求未完成，服务器临时过载或者宕机，一段时间后可恢复正常



#### 什么是持久连接

> 当使用Keep-alive模式（又称持久连接，连接重用 http1.1的版本才支持）时，Keep-alive 功能使客户端到服务端的连接持续有效，当出现服务器的后续请求时，Keep-alive 避免了建立或者重新建立连接



#### HTTPS与HTTP相比

> HTTPS 介绍：HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。

- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。



#### 强制缓存和协商缓存

- 强制缓存是我们在第一次请求资源时在 http 响应头设置一个过期时间，在时效内都将直接从浏览器进行获取，常见的 http 响应头字段如 Cache-Control 和 Expires
- 协商缓存是我们通过 http 响应头字段 etag 或者 Last-Modified 等判断服务器上资源是否修改，如果修改则从服务器重新获取，如果未修改则 304 指向浏览器缓存中进行获取



#### 从输入URL到页面的渲染完成经历了什么过程

1. 浏览器查找当前URL是否存在缓存，并比较缓存是否过期
2. DNS解析URL对应的IP
3. 浏览器与目标服务器建立一条 TCP 连接（三次握手）
4. 浏览器向服务器发送一条 HTTP 请求报文
5. 服务器返回给浏览器一条 HTTP 响应报文
6. 浏览器进行渲染
7. 关闭 TCP 连接（四次挥手）

#### TCP名词释义
> 传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层通信协议


#### TCP的三次握手

1. 第一次握手是在建立连接，客户端发送连接请求报文段，把标有SYN的数据包发送给服务器端

2. 第二次握手是服务端收到客户端的SYN的报文段，同时发送标有SYN/ACK的数据包

3. 第三次握手是客户端收到服务端的SYN/ACK的数据包后，向服务器端发送标有ACK的数据包



#### TCP的四次挥手

1. 客户端设置seq和 ACK ,向服务器发送一个 FIN=1报文段。此时，**（第一次挥手，FIN=1，seq=u）**客户端进入 FIN_WAIT 状态，表示客户端没有数据要发送给服务端了。
2. 服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。
3. 服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。
4. 客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT 状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待 2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。


#### 常见问题

- 为什么连接的时候是三次握手，关闭的时候却是四次握手？

  > 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

- 为什么不能用两次握手进行连接？

  > 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

- TCP为啥要三次握手：

  > 握手过程中使用了TCP的标志，**SYN和ACK。**
  >
  > 初始化状态：客户端处于close关闭状态，服务器处于Listen监听状态。
  >
  > 第一次握手：客户端发送**请求报文将 SYN=1 同步序列号和初始化 seq=x发送给服务端，**服务端从初始化状态，创建连接，等待客户端，确认接收后的状态为SYN_Receive。这个时候**客户端处于等待状态为SYN_Send。**
  >
  > 第二次握手，服务器接收到**报文后（SYN=1，seq=x）**收到请求后**请求报文变为同步序列号SYN=1，初始化序列号seq=1，确认号ACK=1，ack=x+1，服务器为SYN_Receive状态，**发送端的状态为：SYN_Send。
  >
  > 第三次握手，客户端收到服务端的数据包（收到响应后），然后发送同步序列号ack=y+1和数据包的序列号seq=x+1和ACK=1确认包作为应答**（第三次握手：ACK=1,seq=x+1,ack=y+1），**客户端和服务端变化为established状态。
  >
  > 发送三封信息给女朋友，这三次握手主要是为了验证我这边和女朋友那边的发送/收信能力是没有问题的，证明连接是通的，可以正式发送信息。
  >
  > 第一次握手，我发送信息，女朋友收到了，此时女朋友就知道，我发送信息的能力和她自己的收信能力是没问题的。
  >
  > 第二次握手，女朋友发送信息，我收到了，此时我明白，**我的发送信息和接收信息是没有问题的，**还是要进行第三次握手的，如果没有我的回音，女朋友还不知道自己的发送信息功能是否没有问题的。
  >
  > 第三次握手，我发送信息，女朋友收到了，此时女朋友也确认了，我们两者之间的发送和收信都是没有问题的。

- 如果已经建立了连接，但是客户端突然出现故障了怎么办？

  > TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

